pipeline {
	agent {
        label 'catapult-build-node'
    }

    // using the Timestamper plugin we can add timestamps to the console log
    options {
        timestamps()
    }

    environment {
        DOCKER_REGISTRY = "249767383774.dkr.ecr.ap-southeast-1.amazonaws.com"
        CREDENTIAL_ID = "ecr:ap-southeast-1:jenkins-ecr"
        IMAGE = "proximax-catapult-server"
        BUILD_IMAGE = "proximax-catapult-server-dependencies-build-image:v1.2-focal"
    }

	stages {
		stage ('Build') {
            steps {
                echo 'Building catapult-server inside a docker'
                script {
                    withCredentials([string(credentialsId: 'git_token', variable: 'GIT_TOKEN')]) {
                        sh """
                            
                            git config --global url."https://${GIT_TOKEN}:@github.com/".insteadOf "https://github.com/"
                            git submodule update --init --recursive --remote
                            cd cpp-xpx-storage-sdk
                            git checkout bdce0d9d3da429fffad25c18ad39d2f01c33fed9
                            cd ..
                        """
                    }
                    def buildImage = docker.image("${BUILD_IMAGE}")
                    docker.withRegistry("https://${DOCKER_REGISTRY}", "${CREDENTIAL_ID}"){
                        buildImage.inside('-u 0'){
                            sh """
                                echo 'Building libtorrent'
                                apt update && apt install -y libboost-tools-dev
                                cd cpp-xpx-storage-sdk
                                git clone --recurse-submodules https://github.com/arvidn/libtorrent.git
                                cd libtorrent
                                echo \"using gcc ;\" >>~/user-config.jam
                                b2 crypto=openssl cxxstd=14 release
                                b2 install --prefix=/usr/local
                                cd ../../
                                
                                echo 'Building catapult-server'
                                rm -rf _build
                                mkdir _build 
                                cd _build
                                cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-pthread" -DPYTHON_EXECUTABLE=/usr/bin/python3 -DBSONCXX_LIB=/usr/local/lib/libbsoncxx.so -DMONGOCXX_LIB=/usr/local/lib/libmongocxx.so .. 
                                make -j4 publish
                                make -j4
                                cd ..
                                ./scripts/release-script/copyDeps.sh _build/bin/ ./deps
                            """    
                        }
                    }
                }
            }
		}

        stage('Unit Test') {
            steps {
                script {
                    def buildImage = docker.image("${BUILD_IMAGE}")
                    docker.withRegistry("https://${DOCKER_REGISTRY}", "${CREDENTIAL_ID}"){
                        docker.image("mongo:4.4").run("-p 27017:27017") // mongo is required for unit test
                        // to use buildImage with host's network stack
                        buildImage.inside("--net host") {
                            sh """
                                echo 'Running unit tests'
                                # Disable exit on non 0
                                set +e
                                cd _build
                                # pipe to true to prevent exit failure
                                ctest -T Test --no-compress-output || true
                            """
                        }
                    }
                }
            }
            post {
                always {
                    archiveArtifacts "_build/bin/*"
                    xunit (
                        thresholds: [ skipped(failureThreshold: '0'), failed(failureThreshold: '0') ],
                        tools: [ CTest(pattern: "_build/Testing/**/*.xml") ]
                    )
                }
            }
        }

        stage('Build and Publish Release Image') {
            when {
                tag "release-*"   // only run these stage in tag release-*
            }
            steps {
                echo 'Build and Publish Image'
                script {
                    def newImage = docker.build("${IMAGE}","-f ./ci/Dockerfile .")
                    docker.withRegistry("https://${DOCKER_REGISTRY}", "${CREDENTIAL_ID}"){
                        newImage.push("${env.GIT_BRANCH}") // if a tag commit, then env.GIT_BRANCH returns the tag name instead of a branch
                    }
                }
            }
            post {
                success {
                    slackSend channel: '#devops',
                        color: 'good',
                        message: "Release with Tag *${env.GIT_BRANCH}* build of *${currentBuild.fullDisplayName}* completed successfully :100:\nPushed Docker image ${DOCKER_REGISTRY}/${IMAGE}:${env.GIT_BRANCH}"
                }
            }
        }

        stage('Build and Publish Develop Image') {
            when {
                anyOf {
                    branch 'develop';
                    branch 'release-candidate-*'
                }
            }
            steps {
                echo 'Build and Publish Image'

                script {
                    def newImage = docker.build("${IMAGE}","-f ./ci/Dockerfile .")
                    docker.withRegistry("https://${DOCKER_REGISTRY}", "${CREDENTIAL_ID}"){
                        if( env.GIT_BRANCH == 'develop'){
                            newImage.push("develop-jenkins-build-${env.BUILD_NUMBER}") // also push using Jenkins build number
                            newImage.push("develop") // update Docker image develop
                        }else{
                            newImage.push("${env.GIT_BRANCH}-${env.BUILD_NUMBER}")
                        }
                        
                    }
                }
            }
            post {
                success {
                    slackSend channel: '#devops',
                        color: 'good',
                        message: "Branch *${env.GIT_BRANCH}* build of *${currentBuild.fullDisplayName}* completed successfully :100:\nPushed Docker images ${DOCKER_REGISTRY}/${IMAGE}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}"
                }
            }
        }
    }

    post {
        failure {
            slackSend channel: '#devops',
              color: 'bad',
              message: "Branch *${env.GIT_BRANCH}* of *${currentBuild.fullDisplayName}* FAILED :scream:"
        }
    }
}
